// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **

import {SameCallHandler} from './same-call-handler';
import {MockService} from '../../../mock-service';
import {Mutation} from '../../../../../mutation';

function rowResponse(rowKey: {}) {
  return {
    rowKey: Mutation.convertToBytes(rowKey),
    familyName: {value: 'family'},
    qualifier: {value: Mutation.convertToBytes('qualifier')},
    valueSize: 0,
    timestampMicros: 0,
    labels: [],
    commitRow: true,
    value: Mutation.convertToBytes('value'),
  };
}

export interface ReadRowsResponse {
  row_keys: string[];
  last_row_key: string;
  end_with_error: number;
}

export class ReadRowsHandler extends SameCallHandler {
  responses: ReadRowsResponse[];
  request: any = null;
  callCount = 0;
  message: any;

  // TODO: service and endpoint should be bundled into one object.
  constructor(
    service: MockService,
    endpoint: string,
    responses: ReadRowsResponse[],
    message?: any
  ) {
    super(service, endpoint);
    this.responses = responses;
    this.message = Object.assign({}, message);
  }
  /*
  callHandler(call: any) {
    const checkCollected = () => {
      console.log('emit error');
      call.emit('error', {
        code: 4,
        details: 'Details for a particular type of error',
      });
    };
    const startTimer = () => {
      setTimeout(checkCollected, 2500);
    };
    startTimer();
  }
  */
  // TODO: Create interface for this.
  callHandler(call: any) {
    const lastResponse = this.responses[this.callCount - 1];
    if (lastResponse) {
      const grpcResponse = {
        chunks: lastResponse.row_keys.map(rowResponse),
        lastScannedRowKey: Mutation.convertToBytes(lastResponse.last_row_key),
      };
      call.write(grpcResponse);
    }
    // Send an error right away
    // const errorCode = lastResponse.error_on_call;
    // if (errorCode) {
    //   call.emit('error', {
    //     code: errorCode,
    //     details: 'Details for a particular type of error',
    //   });
    // }
    // callHandler(call: any) {
    //   const self = this;
    //   const sendError = () => {
    //     console.log(self.data);
    //     call.emit('error', {
    //       code: 4,
    //       details: 'Details for a particular type of error',
    //     });
    //   };
    //   setTimeout(sendError, 2500);
    // }
    // Set a timer and send an error if we are confident that all data has been sent back to the user
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const self = this;
    const checkCollected = () => {
      // Send the error if all data was collected
      const lastIndex = self.data.length - 1;
      const lastResponse = self.responses[self.callCount - 1];
      if (lastResponse) {
        console.log(self.data[lastIndex]);
        if (self.data[lastIndex].length === lastResponse.row_keys.length) {
          const errorCode = lastResponse.end_with_error;
          if (errorCode) {
            console.log('emit error');
            call.emit('error', {
              code: errorCode,
              details: 'Details for a particular type of error',
            });
          }
        } else {
          startTimer();
        }
      } else {
        throw Error('Response data should have been provided in the test');
      }
    };
    const startTimer = () => {
      setTimeout(checkCollected, 2500);
    };
    startTimer();
  }

  addData(data: string) {
    // Add data collected from the stream
    const lastIndex = this.data.length - 1;
    this.data[lastIndex].push(data);
  }

  snapshot(results: any): any {
    return {
      input: Object.assign(
        {responses: this.responses},
        this.message ? {message: this.message} : null
      ),
      output: {
        results,
        requestData: this.requests(),
      },
    };
  }
}
