// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **

import {before, describe, it} from 'mocha';
import {Bigtable} from '../../src';
import * as assert from 'assert';

import {GoogleError, grpc, ServiceError} from 'google-gax';
import {MockServer} from '../../src/util/mock-servers/mock-server';
import {BigtableClientMockService} from '../../src/util/mock-servers/service-implementations/bigtable-client-mock-service';
import {MockService} from '../../src/util/mock-servers/mock-service';
const snapshot = require('snap-shot-it');
import {check} from 'linkinator';
import * as gax from 'google-gax';

function isServiceError(error: any): error is ServiceError {
  return (
    error.code !== undefined &&
    error.details !== undefined &&
    error.metadata !== undefined
  );
}

describe('Bigtable/ReadRows', () => {
  let server: MockServer;
  let service: MockService;
  let bigtable: Bigtable;
  let table: any;

  before(done => {
    server = new MockServer(() => {
      bigtable = new Bigtable({
        apiEndpoint: `localhost:${server.port}`,
      });
      // TODO: Replace this with generated Ids so that we don't have flaky tests
      table = bigtable.instance('fake-instance').table('fake-table');
      service = new BigtableClientMockService(server);
      done();
    });
  });

  describe('with a mock server that always sends an error back', () => {
    // Define the standard call here
    describe('where the error is retryable', () => {
      function checkRequest(code: grpc.status, callback: () => void) {
        const errorDetails = 'Details for a particular type of error';
        let request: any = null;
        let callCount = 0;
        const emitError = (stream: any) => {
          const streamRequest = stream.request;
          if (request) {
            // This ensures that every call to the server is the same
            assert.deepStrictEqual(request, streamRequest);
          } else {
            request = streamRequest;
          }
          callCount++;
          stream.emit('error', {
            code,
            details: errorDetails,
          });
        };
        service.setService({
          // Abstraction: Always emit error
          ReadRows: emitError,
        });
        table.createReadStream({}).on('error', (error: ServiceError) => {
          snapshot({
            code,
            callCount,
            request,
          });
          callback();
        });
      }
      function checkForCodes(codes: Array<grpc.status>, callback: () => void) {
        function withNextCode() {
          const code = codes.pop();
          if (code) {
            checkRequest(code, withNextCode);
          } else {
            callback();
          }
        }
        withNextCode();
      }
      it('should ensure correct behavior with retryable errors', done => {
        const status = grpc.status;
        const codes: Array<grpc.status> = [
          status.DEADLINE_EXCEEDED,
          status.RESOURCE_EXHAUSTED,
          status.ABORTED,
          status.UNAVAILABLE,
        ];
        checkForCodes(codes, done);
      });
    });
  });
  after(async () => {
    server.shutdown(() => {});
  });
});
